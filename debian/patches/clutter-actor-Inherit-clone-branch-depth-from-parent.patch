From: Daniel van Vugt <daniel.van.vugt@canonical.com>
Date: Mon, 21 May 2018 18:24:58 +0800
Subject: clutter/actor: Inherit clone branch depth from parent

Children added to a parent after that parent (or its ancestors)
have already been cloned now inherit the clone branch depth of
the parent. Otherwise `clutter_actor_is_in_clone_paint` on the child
could return FALSE when it should have been returning TRUE.

Origin: upstream, 3.29.91, commit:b393f3d54018b85137078664d548c0c661001ff1
---
 clutter/clutter/clutter-actor.c | 29 +++++++++++++++++++++--------
 1 file changed, 21 insertions(+), 8 deletions(-)

diff --git a/clutter/clutter/clutter-actor.c b/clutter/clutter/clutter-actor.c
index 2ba61ba..34baefd 100644
--- a/clutter/clutter/clutter-actor.c
+++ b/clutter/clutter/clutter-actor.c
@@ -1093,6 +1093,11 @@ static void clutter_actor_set_child_transform_internal (ClutterActor        *sel
 static void     clutter_actor_realize_internal          (ClutterActor *self);
 static void     clutter_actor_unrealize_internal        (ClutterActor *self);
 
+static void clutter_actor_push_in_cloned_branch (ClutterActor *self,
+                                                 gulong        count);
+static void clutter_actor_pop_in_cloned_branch (ClutterActor *self,
+                                                gulong        count);
+
 /* Helper macro which translates by the anchor coord, applies the
    given transformation and then translates back */
 #define TRANSFORM_ABOUT_ANCHOR_COORD(a,m,c,_transform)  G_STMT_START { \
@@ -4289,6 +4294,9 @@ clutter_actor_remove_child_internal (ClutterActor                 *self,
 
   self->priv->age += 1;
 
+  if (self->priv->in_cloned_branch)
+    clutter_actor_pop_in_cloned_branch (child, self->priv->in_cloned_branch);
+
   /* if the child that got removed was visible and set to
    * expand then we want to reset the parent's state in
    * case the child was the only thing that was making it
@@ -12910,6 +12918,9 @@ clutter_actor_add_child_internal (ClutterActor              *self,
 
   self->priv->age += 1;
 
+  if (self->priv->in_cloned_branch)
+    clutter_actor_push_in_cloned_branch (child, self->priv->in_cloned_branch);
+
   /* if push_internal() has been called then we automatically set
    * the flag on the actor
    */
@@ -20704,29 +20715,31 @@ clutter_actor_get_child_transform (ClutterActor  *self,
 }
 
 static void
-clutter_actor_push_in_cloned_branch (ClutterActor *self)
+clutter_actor_push_in_cloned_branch (ClutterActor *self,
+                                     gulong        count)
 {
   ClutterActor *iter;
 
   for (iter = self->priv->first_child;
        iter != NULL;
        iter = iter->priv->next_sibling)
-    clutter_actor_push_in_cloned_branch (iter);
+    clutter_actor_push_in_cloned_branch (iter, count);
 
-  self->priv->in_cloned_branch += 1;
+  self->priv->in_cloned_branch += count;
 }
 
 static void
-clutter_actor_pop_in_cloned_branch (ClutterActor *self)
+clutter_actor_pop_in_cloned_branch (ClutterActor *self,
+                                    gulong        count)
 {
   ClutterActor *iter;
 
-  self->priv->in_cloned_branch -= 1;
+  self->priv->in_cloned_branch -= count;
 
   for (iter = self->priv->first_child;
        iter != NULL;
        iter = iter->priv->next_sibling)
-    clutter_actor_pop_in_cloned_branch (iter);
+    clutter_actor_pop_in_cloned_branch (iter, count);
 }
 
 void
@@ -20742,7 +20755,7 @@ _clutter_actor_attach_clone (ClutterActor *actor,
 
   g_hash_table_add (priv->clones, clone);
 
-  clutter_actor_push_in_cloned_branch (actor);
+  clutter_actor_push_in_cloned_branch (actor, 1);
 }
 
 void
@@ -20757,7 +20770,7 @@ _clutter_actor_detach_clone (ClutterActor *actor,
       g_hash_table_lookup (priv->clones, clone) == NULL)
     return;
 
-  clutter_actor_pop_in_cloned_branch (actor);
+  clutter_actor_pop_in_cloned_branch (actor, 1);
 
   g_hash_table_remove (priv->clones, clone);
 
